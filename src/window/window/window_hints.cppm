module;

#include <GLFW/glfw3.h>

export module void_engine.window:window_hints;

import std;
import glm;

export namespace void_engine::window {

enum class context_client_api : std::uint32_t {
	none = GLFW_NO_API,
	opengl = GLFW_OPENGL_API,
	opengl_es = GLFW_OPENGL_ES_API,
};

enum class context_creation_api : std::uint32_t {
	native = GLFW_NATIVE_CONTEXT_API,
	egl = GLFW_EGL_CONTEXT_API,
	osmesa = GLFW_OSMESA_CONTEXT_API,
};

enum class context_robustness : std::uint32_t {
	none = GLFW_NO_ROBUSTNESS,
	no_reset_notification = GLFW_NO_RESET_NOTIFICATION,
	lose_context_on_reset = GLFW_LOSE_CONTEXT_ON_RESET,
};

enum class context_release_behavior : std::uint32_t {
	any = GLFW_ANY_RELEASE_BEHAVIOR,
	flush = GLFW_RELEASE_BEHAVIOR_FLUSH,
	none = GLFW_RELEASE_BEHAVIOR_NONE,
};

enum class context_opengl_profile : std::uint32_t {
	any = GLFW_OPENGL_ANY_PROFILE,
	compatibility = GLFW_OPENGL_COMPAT_PROFILE,
	core = GLFW_OPENGL_CORE_PROFILE,
};

struct window_hints {
	struct {
		// Whether the window will be resizable by the user.
		bool resizable = true;
		// Whether the window will be initially visible.
		bool visible = true;
		// Whether the window will have window decorations such as a border, a close widget, etc.
		bool decorated = true;
		// Whether the window will be given input focus when created.
		bool focused = true;
		// Weather the full screen window will automatically minimize and restore the previous video mode on input focus
		// loss.
		bool auto_minimize = true;
		// Whether the window will be always on top of other regular windows.
		bool floating = false;
		// Whether the windowed mode window will be maximized when created.
		bool maximized = false;
		// Whether the cursor should be centered over newly created full screen windows.
		bool center_cursor = true;
		// Whether window framebuffer will be transparent.
		bool transparent_framebuffer = false;
		// Whether the window will be given input focus when shown.
		bool focus_on_show = true;
		// Whether the window content area should be resized based on monitor content scale changes.
		bool scale_to_monitor = false;
		// Whether the framebuffer should be resized based on monitor content scale changes.
		bool scale_framebuffer = true;
		// Whether the window is transparent to mouse input.
		bool mouse_passthrough = false;
		// The initial position of the window.
		glm::ivec2 position = {std::numeric_limits<int>::min(), std::numeric_limits<int>::min()};
	} window{};

	struct {
		// The desired bit depth of color components in the default framebuffer.
		glm::ivec4 color_bits = {8, 8, 8, 8};
		// The desired bit depth of the default framebuffer's depth buffer.
		std::int32_t depth_bits = 24;
		// The desired bit depth of the default framebuffer's stencil buffer.
		std::int32_t stencil_bits = 8;
		// The desired bit depth of color components in the accumulation buffer.
		glm::ivec4 accumulation_color_bits = {0, 0, 0, 0};
		// The desired number of auxiliary buffers.
		std::int32_t auxiliary_buffers = 0;
		// Weather to use stereoscopic rendering.
		bool stereo = false;
		// The desired number of samples to use for multisampling.
		std::int32_t samples = 0;
		// Weather the framebuffer should be sRGB capable.
		bool srgb_capable = false;
		// Weather the framebuffer should be double buffered.
		bool doublebuffer = true;
	} framebuffer{};

	struct {
		// The desired refresh rate for full screen windows.
		std::int32_t refresh_rate = -1;
	} monitor{};

	struct {
		// Which client API to create the context for.
		context_client_api client_api = context_client_api::opengl;
		// Which context creation API to use to create the context.
		context_creation_api creation_api = context_creation_api::native;
		// The client API version that the created context must be compatible with.
		std::pair<int, int> version = {4, 6};
		// Whether the OpenGL context should be forward-compatible.
		bool opengl_forward_compat = false;
		// Whether the context should be created in debug mode.
		bool debug = false;
		// Which OpenGL profile to create the context for.
		context_opengl_profile opengl_profile = context_opengl_profile::core;
		// The robustness strategy to be used by the context.
		context_robustness robustness = context_robustness::none;
		// The release behavior to be used by the context.
		context_release_behavior release_behavior = context_release_behavior::any;
		// Whether errors should be generated by the context.
		bool no_error = false;
	} context{};

	struct {
		// Whether to allow access to the window menu via the Alt+Space and Alt-and-then-Space keyboard shortcuts.
		bool keyboard_menu = false;
		// Whether to show the window the way specified in the program's STARTUPINFO when it is shown for the first time.
		bool showdefault = false;
	} win32{};

	struct {
		// The UTF-8 encoded name to use for autosaving the window frame, or if empty disables frame autosaving for the
		// window.
		std::string frame_name;
		// Whether to enable automatic graphics switching to the most appropriate GPU on multi-GPU systems.
		bool graphics_switching = false;
	} cocoa{};

	struct {
		// The Wayland app_id for a window, used by window managers to identify types of windows.
		std::string app_id;
	} wayland{};

	struct x11_hints {
		// The desired ASCII encoded class part of the ICCCM WM_CLASS window property.
		std::string class_name;
		// The desired ASCII encoded instance part of the ICCCM WM_CLASS window property.
		std::string instance_name;
	} x11{};
};

} // namespace void_engine::window
